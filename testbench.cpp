#include "verilated.h"
#include "VArgon.h" // Generated by Verilator from Argon.sv
#include "verilated_fst_c.h" // For FST waveform tracing
#include <iostream>
#include <iomanip>
#include <string>

VArgon* top;
VerilatedFstC* tfp; // Trace file pointer
vluint64_t sim_time = 0; // Manual simulation time counter
uint64_t clock_count = 0; // Track clock cycles
bool debug_mode = false; // Default to false

void simClockFall() {
    top->i_clk = 0;
    top->eval();
    tfp->dump(sim_time);
    sim_time++;
    if (debug_mode) {
        std::cout << "Clock fall, time: " << sim_time << "\n";
    }
}

void simClockRise() {
    top->i_clk = 1;
    top->eval();
    tfp->dump(sim_time);
    sim_time++;
    if (debug_mode) {
        std::cout << "Clock rise, time: " << sim_time << "\n";
    }
}

void simClock(int cycles = 1) {
    for (int i = 0; i < cycles; i++) {
        simClockRise();
        simClockFall();
        clock_count++;
    }
}

void simreset() {
    top->i_reset = 1;
    simClock();
    top->i_reset = 0;
    std::cout << "Reset complete\n";
}

// Helper function to format 32-bit value as binary with underscores
std::string to_binary(uint32_t value) {
    std::string bin;
    for (int i = 31; i >= 0; i--) {
        bin += (value & (1U << i)) ? "1" : "0";
        if (i % 4 == 0 && i > 0) bin += "_";
    }
    return bin;
}

// Helper function to test register file
bool test_register(uint8_t selectA, uint8_t selectB, uint8_t selectW, uint32_t write_data, bool write_en, uint32_t expected_portA, uint32_t expected_portB, const std::string& test_name) {
    top->i_selectA = selectA;
    top->i_selectB = selectB;
    top->i_selectW = selectW;
    top->i_portW = write_data;
    top->i_write_en = write_en;
    simClock(); // Run one clock cycle to process

    bool pass = (top->o_portA == expected_portA) && (top->o_portB == expected_portB);
    std::cout << "Test " << test_name << ": "
              << "selectA=0x" << std::hex << std::setw(2) << std::setfill('0') << (int)selectA
              << ", selectB=0x" << std::setw(2) << std::setfill('0') << (int)selectB
              << ", selectW=0x" << std::setw(2) << std::setfill('0') << (int)selectW
              << ", write_data=0x" << std::setw(8) << std::setfill('0') << write_data
              << ", write_en=" << (write_en ? "1" : "0")
              << ", portA=0x" << std::setw(8) << std::setfill('0') << top->o_portA
              << ", portB=0x" << std::setw(8) << std::setfill('0') << top->o_portB
              << ", ExpectedA=0x" << std::setw(8) << std::setfill('0') << expected_portA
              << ", ExpectedB=0x" << std::setw(8) << std::setfill('0') << expected_portB
              << (pass ? " [PASS]" : " [FAIL]") << "\n";
    return pass;
}

int main(int argc, char** argv) {
    Verilated::commandArgs(argc, argv);
    top = new VArgon; // Instantiate the top module

    // Initialize FST tracing
    Verilated::traceEverOn(true);
    tfp = new VerilatedFstC;
    top->trace(tfp, 99); // Trace 99 levels of hierarchy
    tfp->open("dump.fst"); // Root directory

    if (!tfp->isOpen()) {
        std::cerr << "Failed to open dump.fst for writing\n";
        delete top;
        return 1;
    }
    std::cout << "Tracing initialized, writing to dump.fst\n";

    std::cout << "\n=== Simulation Begin ===\n";
    simreset();

    // Run tests
    bool all_tests_passed = true;

    // Test 1: Write to register 5, read from register 5 and register 0
    all_tests_passed &= test_register(
        5,           // selectA: read from register 5
        0,           // selectB: read from register 0
        5,           // selectW: write to register 5
        0xDEADBEEF,  // write_data
        1,           // write_en
        0xDEADBEEF,  // expected_portA (register 5)
        0x00000000,  // expected_portB (register 0 always 0)
        "Write and Read Reg 5, Read Reg 0"
    );

    // Test 2: Read from register 5 and register 1 (unwritten, should be 0 after reset)
    all_tests_passed &= test_register(
        5,           // selectA: read from register 5
        1,           // selectB: read from register 1
        0,           // selectW: no write
        0x00000000,  // write_data: irrelevant
        0,           // write_en: disabled
        0xDEADBEEF,  // expected_portA (register 5 retains value)
        0x00000000,  // expected_portB (register 1 is 0)
        "Read Reg 5 and Reg 1 (no write)"
    );

    // Cleanup
    std::cout << "Simulation complete, clock cycles: " << clock_count << "\n";
    tfp->close();
    delete tfp;
    delete top;
    if (all_tests_passed) {
        std::cout << "All tests passed!\n";
    } else {
        std::cout << "Some tests failed.\n";
        return 1;
    }
    return 0;
}