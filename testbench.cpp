#include "verilated.h"
#include "VArgonTB.h" // Generated by Verilator from Argon.sv
#include "verilated_fst_c.h" // For FST waveform tracing
#include <iostream>
#include <iomanip>
#include <string>
#include <cstdio>

VArgonTB* top;
VerilatedFstC* tfp; // Trace file pointer
vluint64_t sim_time = 0; // Manual simulation time counter
uint64_t clock_count = 0; // Track clock cycles
bool debug_mode = false; // Default to false

void simClockFall() {
    top->i_clk = 0;
    top->eval();
    tfp->dump(sim_time);
    sim_time++;
    if (debug_mode) {
        std::cout << "Clock fall, time: " << sim_time << "\n";
    }
}

void simClockRise() {
    top->i_clk = 1;
    top->eval();
    tfp->dump(sim_time);
    sim_time++;
    if (debug_mode) {
        std::cout << "Clock rise, time: " << sim_time << "\n";
    }
}

void simClock(int cycles = 1) {
    for (int i = 0; i < cycles; i++) {
        simClockRise();
        simClockFall();
        clock_count++;
    }
}

void simreset() {
    top->i_reset = 1;
    simClock();
    top->i_reset = 0;
    std::cout << "Reset complete\n";
}

// Helper function to format 32-bit value as binary with underscores
std::string to_binary(uint32_t value) {
    std::string bin;
    for (int i = 31; i >= 0; i--) {
        bin += (value & (1U << i)) ? "1" : "0";
        if (i % 4 == 0 && i > 0) bin += "_";
    }
    return bin;
}

int main(int argc, char** argv) {
    Verilated::commandArgs(argc, argv);
    top = new VArgonTB; // Instantiate the top module

    // Initialize FST tracing
    Verilated::traceEverOn(true);
    tfp = new VerilatedFstC;
    top->trace(tfp, 99); // Trace 99 levels of hierarchy
    tfp->open("dump.fst"); // Root directory

    if (!tfp->isOpen()) {
        std::cerr << "Failed to open dump.fst for writing\n";
        delete top;
        return 1;
    }
    std::cout << "Tracing initialized, writing to dump.fst\n";

    std::cout << "\n=== Simulation Begin ===\n";
    simreset();

    // Simulation
    simClock(2); // initial instruction load
    for (int i = 0; i < 5; i++) {
        top->i_halt = 1;
        simClock(1);
        top->i_halt = 0;
        simClock(5); // instruction
    }

    // Cleanup
    std::cout << "Simulation complete, clock cycles: " << clock_count << "\n";
    tfp->close();
    delete tfp;
    delete top;
    return 0;
}